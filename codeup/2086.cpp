/* 动态规划：最大连续子序列 */
/******************************************************************************
 题目描述
给定K个整数的序列{ N1, N2, ..., NK }，其任意连续子序列可表示为{ Ni, Ni+1, ..., Nj }，其中 1 <= i <= j <= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。

输入
测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K<= 10000 )，第2行给出K个整数，中间用空格分隔，每个数的绝对值不超过100。当K为0时，输入结束，该用例不被处理。

输出
对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。

样例输入
5
-3 9 -2 5 -4
3
-2 -3 -1
0
样例输出
12 9 5
0 -2 -1
提示

这是一道稍微有点难度的动态规划题。 
首先可以想到的做法是枚举每个区间的和，预处理sum[i]来表示区间[1, i]的和之后通过减法我们可以O(1)时间获得区间[i, j]的和，因此这个做法的时间复杂度为O(n^2)。 
然后这题的数据范围较大，因此还需作进一步优化才可以AC。记第i个元素为a[i]，定义dp[i]表示以下标i结尾的区间的最大和，那么dp[i]的计算有2种选择，一种是含有a[i-1]，一种是不含有a[i-1]，前者的最大值为dp[i-1]+a[i]，后者的最大值为a[i]。而两者取舍的区别在于dp[i-1]是否大于0。
******************************************************************************/

#include <cstdio>

int main() {
    int n;
    while (scanf("%d", &n), n) {
        int arr[n];
        for (int i = 0;i < n; i++) {
            scanf("%d", &arr[i]);
        }
        int dp[n];
        dp[0] = arr[0];
        int max = dp[0];
        int l = 0, r = 0;
        for (int i = 0 ; i < n - 1; i++) {
            dp[i + 1] = dp[i] < 0 ? arr[i + 1] : dp[i] + arr[i + 1];
            if (dp[i + 1] > max) {
                max = dp[i + 1];
                l = dp[i] < 0 ? i + 1 : l;
                r = i + 1;
            }
        }
        if (max < 0) {
            printf("%d %d %d\n", 0, arr[0], arr[n - 1]);
        } else {
            printf("%d %d %d\n", max, arr[l], arr[r]);
        }
    }
    return 0;
}



/* 动态规划连续子序列之和 */
/******************************************************************************
#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 10010;
int A[maxn], dp[maxn];
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &A[i]);
    }
    // 边界
    dp[0] = A[0];
    for (int i = 0\1; i < n; i++) {
        dp[i] = max(A[i], dp[i - 1] + A[i]);
    }
    // dp[i] 存放以A[i]结尾的连续序列的最大和，需要遍历i得到最大的才是结果
    int k = 0;
    for (int i = 1; i < n; i++) {
        if (dp[i] > dp[k]) {
            k = i;
        }
    }
    printf("%d\n", dp[k]);
    return 0;
}
******************************************************************************/